<!DOCTYPE html>
<html>
<head>
  <title>NCCGA Regional Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { margin:0; padding:0; }
    #map { height: 100vh; }

    .qualifier-icon {
      filter: drop-shadow(0 0 2px #fff) drop-shadow(0 0 1.5px #000);
    }
    .leaflet-div-icon.flag-div { background: transparent; border: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Turf for point-in-polygon + buffering line regions -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const map = L.map('map').setView([39.5, -98.35], 4);

    // ===== Panes & stacking order =====
    map.createPane('regionPane');     map.getPane('regionPane').style.zIndex = 450;
    map.createPane('schoolPane');     map.getPane('schoolPane').style.zIndex = 650;
    map.createPane('tournamentPane'); map.getPane('tournamentPane').style.zIndex = 660;
    map.createPane('qualifierPane');  map.getPane('qualifierPane').style.zIndex = 670;

    // ---------- Normalizer (used for grouping keys only) ----------
    const clean = str => String(str || '')
      .toLowerCase()
      .replace(/region/g, '')
      .replace(/capitol/g, 'capital')
      .replace(/[\s\-_().]/g, '')
      .trim();

    // ---------- Fixed palette (yours, unchanged; added # for Great Lakes) ----------
    const REGION_COLORS = {
      "Atlantic Region":             "#1f78b4",
      "Northeast Region":            "#33a02c",
      "Capitol Region":              "#e31a1c",
      "Colonial Region":             "#ff7f00",
      "Carolina Region":             "#6a3d9a",
      "Desert Region":               "#b15928",
      "Mountain Region":             "#a6cee3",
      "Pacific Region":              "#b2df8a",
      "Northwest Region":            "#fb9a99",
      "Ohio Valley Region":          "#fdbf6f",
      "Midwest Region":              "#cab2d6",
      "Southern New England Region": "#80cdc1",
      "North Florida Region":        "#01665e",
      "South Florida Region":        "#8e0152",
      "Texas Region":                "#5e3c99",
      "Northern California Region":  "#c51b7d",
      "Southern California Region":  "#35978f",
      "Indiana Region":              "#80b1d3",
      "Northern New England Region": "#8B4513",
      "Twin Cities Region":          "#33a02c",
      "Great Lakes Region":          "#800000",
      "Philadelphia Region":         "#4B0082"  
    };

    const COLOR_BY_KEY = {};
    Object.entries(REGION_COLORS).forEach(([name, color]) => {
      COLOR_BY_KEY[clean(name)] = color;
    });

    // Optional short aliases you might see in data
    const REGION_ALIASES = {
      philadelphia: 'colonial', philly: 'colonial',
      tx: 'texas',
      norcal: 'northerncalifornia', nocal: 'northerncalifornia',
      socal: 'southerncalifornia',  scal: 'southerncalifornia'
    };

    // Prefer the tournament's label; fall back to polygon if unknown
    const PREFER_TOURNAMENT_LABEL = true;

    function hashColor(name = "default") {
      let h = 0; for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) | 0;
      const hue = Math.abs(h) % 360; return `hsl(${hue},70%,45%)`;
    }
    function getRegionColorByName(name) {
      const key = clean(name);
      return COLOR_BY_KEY[key] || hashColor(name || "");
    }
    function resolveRegionKey(name) {
      const k = clean(name);
      if (COLOR_BY_KEY[k]) return k;
      const alias = REGION_ALIASES[k];
      if (alias && COLOR_BY_KEY[alias]) return alias;
      return k;
    }

    // Layers
    const schoolRegionLayer = L.layerGroup().addTo(map);
    const tournamentLayer   = L.layerGroup().addTo(map);
    const qualifierLayer    = L.layerGroup().addTo(map);

    // Basemap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const bottomCenterAnchor = size => [Math.round(size[0] / 2), size[1]];
    const loadJSON = (url) => fetch(url).then(r => { if (!r.ok) throw new Error(url+': '+r.status); return r.json(); });

    // === SVG tournament flag (cloth colorable) ===
    function makeSvgFlagIcon(color, size = [18, 24]) {
      const [w, h] = size;
      const html = `
        <svg width="${w}" height="${h}" viewBox="0 0 18 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <ellipse cx="9" cy="22" rx="6" ry="3" fill="#000"/>
          <rect x="8" y="3" width="2" height="18" fill="#000"/>
          <polygon points="10,6 10,12 18,9" fill="${color}"/>
        </svg>`;
      return L.divIcon({
        html,
        className: 'flag-div',
        iconSize: [w, h],
        iconAnchor: [Math.round(w/2), h],
        popupAnchor: [0, -Math.round(h*0.8)]
      });
    }

    // ===== Load data (regions first so we can color tournaments) =====
    Promise.all([
      loadJSON('regions.geojson'),
      loadJSON('schools.geojson').catch(() => null),
      loadJSON('tournaments.geojson').catch(() => null),
      loadJSON('qualifiers.geojson').catch(() => null),
    ]).then(([regions, schools, tournaments, qualifiers]) => {

      // --- Convert non-polygon region geometries into thin polygons for hit-testing ---
      function toPolygonFeature(feat) {
        const g = feat && feat.geometry ? feat.geometry : {};
        if (g.type === 'Polygon' || g.type === 'MultiPolygon') return feat;
        try {
          // buffer by ~5 km to create a polygon shell around lines
          return turf.buffer(feat, 5, { units: 'kilometers' });
        } catch {
          return feat; // fallback (won't match, but won't crash)
        }
      }

      // --- Build region polygon list for point-in-polygon coloring ---
      const regionPolys = (regions?.features || []).map(f => {
        const polyFeat = toPolygonFeature(f);
        return {
          feature: polyFeat,
          key: clean(f.properties?.region),
          name: f.properties?.region,
          color: getRegionColorByName(f.properties?.region)
        };
      });

      // Prefer label; fall back to polygon; final fallback = hashed color
      function colorAndKeyForPointOrLabel(lat, lng, labelName) {
        const labelKey = resolveRegionKey(labelName);
        const labelKnown = !!COLOR_BY_KEY[labelKey];

        if (PREFER_TOURNAMENT_LABEL && labelKnown) {
          return { color: COLOR_BY_KEY[labelKey], key: labelKey, name: labelName || '', source: 'label' };
        }

        const pt = turf.point([lng, lat]);
        for (const r of regionPolys) {
          if (turf.booleanPointInPolygon(pt, r.feature)) {
            return { color: r.color, key: r.key, name: r.name, source: 'polygon' };
          }
        }

        return { color: hashColor(labelName || ''), key: labelKey, name: labelName || '', source: 'fallback' };
      }

      // --- Visible region outlines (non-interactive) ---
      const regionsVisible = L.geoJSON(regions, {
        pane: 'regionPane',
        style: f => ({
          color: getRegionColorByName(f.properties?.region),
          weight: 2,
          fillOpacity: 0.2,
          interactive: false
        })
      }).addTo(schoolRegionLayer);

      // --- Schools (clicks must win) ---
      if (schools) {
        L.geoJSON(schools, {
          pane: 'schoolPane',
          pointToLayer: (feature, latlng) => {
            const p = feature.properties || {};
            const color = getRegionColorByName(p.region);
            const url = `https://nccga.org/app/teams/${p.slug}`;

            const m = L.circleMarker(latlng, {
              pane: 'schoolPane',
              radius: 6,
              fillColor: color,
              color: "#333",
              weight: 1,
              opacity: 1,
              fillOpacity: 0.9,
              bubblingMouseEvents: false,
              interactive: true
            });

            m.on('click', e => {
              if (e.originalEvent) {
                L.DomEvent.stop(e.originalEvent);
                e.originalEvent._clickedSchool = true;
              }
              m.bindPopup(
                `<strong><a href="${url}" target="_blank">${p.school}</a></strong><br>${p.region}`
              ).openPopup();
              if (m.bringToFront) m.bringToFront();
            });

            return m;
          }
        }).addTo(schoolRegionLayer);
      }

      // --- Storage for popup lists ---
      const tournamentsByRegionKey = {};
      const qualifiersByRegionKey  = {};

      // --- Tournaments (label-preferred coloring) ---
      const TOURN_SIZE = [18, 24];

      if (tournaments) {
        L.geoJSON(tournaments, {
          pane: 'tournamentPane',
          pointToLayer: (feature, latlng) => {
            const p = feature.properties || {};
            const { color, key, source } = colorAndKeyForPointOrLabel(latlng.lat, latlng.lng, p.region);

            // keep for region popups (group by the same key we colored with)
            (tournamentsByRegionKey[key] ||= []).push({ ...p });

            if (source === 'fallback' && p.region) {
              console.warn('Tournament outside all regions and label unknown; using fallback color:', p.region, feature);
            } else if (source === 'label') {
              // uncomment if you want to see when label overrides polygon
              // console.info('Colored by label (overrode geometry):', p.course_name || p, p.region);
            }

            return L.marker(latlng, { icon: makeSvgFlagIcon(color, TOURN_SIZE) });
          },
          onEachFeature: (feature, layer) => {
            const { course_name, region, website, date } = feature.properties || {};
            let html = `<strong>${course_name || 'Tournament'}</strong>`;
            if (region) html += `<br>${region}`;
            if (date)   html += `<br><em>${date}</em>`;
            if (website) html += `<br><a href="${website}" target="_blank">Course Website</a>`;
            layer.bindPopup(html);
          }
        }).addTo(tournamentLayer);
      }

      // --- Qualifiers (PNG icon) ---
      const QUAL_SIZE = [26, 26];
      const qualifierIcon = L.icon({
        iconUrl: 'img/Qualifier_flag_icon.png',
        iconSize: QUAL_SIZE,
        iconAnchor: bottomCenterAnchor(QUAL_SIZE),
        popupAnchor: [0, -Math.round(QUAL_SIZE[1] * 0.9)],
        className: 'qualifier-icon'
      });

      if (qualifiers) {
        L.geoJSON(qualifiers, {
          pane: 'qualifierPane',
          pointToLayer: (feature, latlng) => L.marker(latlng, { icon: qualifierIcon }),
          onEachFeature: (feature, layer) => {
            const { course_name, region, regions, website, date } = feature.properties || {};
            const labels = Array.isArray(regions)
              ? regions
              : (typeof region === 'string' ? region.split(',').map(s => s.trim()).filter(Boolean) : []);
            const keys = labels.length ? labels.map(l => clean(l)) : [clean(region || '')];
            keys.forEach(k => (qualifiersByRegionKey[k] ||= []).push(feature.properties || {}));

            const label = Array.isArray(regions) ? regions.join(', ') : (region || 'Qualifier');
            let html = `<strong>${course_name || 'Qualifier'}</strong><br>${label}`;
            if (date) html += `<br><em>${date}</em>`;
            if (website) html += `<br><a href="${website}" target="_blank">Course Website</a>`;
            layer.bindPopup(html);
          }
        }).addTo(qualifierLayer);
      }

      // --- Invisible interactive region layer for popups/zoom ---
      regions.features.forEach(regionFeature => {
        const regionName = regionFeature.properties?.region || 'Region';
        const key = clean(regionName);
        const schoolsList = regionFeature.properties?.schools || [];
        const tList = tournamentsByRegionKey[key] || [];
        const qList = qualifiersByRegionKey[key] || [];

        const schoolsHtml = (schoolsList.length
          ? schoolsList.map(s => `<li>${s}</li>`).join('')
          : '<li>No schools listed.</li>');

        const tournamentsHtml = (tList.length
          ? tList.map(t => {
              let html = `<li><strong>${t.course_name || 'Tournament'}</strong>`;
              if (t.date) html += `<br><em>${t.date}</em>`;
              if (t.website) html += `<br><a href="${t.website}" target="_blank">Course Website</a>`;
              html += `</li>`;
              return html;
            }).join('')
          : '<li>No tournaments scheduled.</li>');

        const qualifiersHtml = (qList.length
          ? qList.map(q => {
              let html = `<li><strong>${q.course_name || q.course || 'Qualifier'}</strong>`;
              if (q.date) html += `<br><em>${q.date}</em>`;
              if (q.website) html += `<br><a href="${q.website}" target="_blank">Course Website</a>`;
              html += `</li>`;
              return html;
            }).join('')
          : '<li>No qualifiers scheduled.</li>');

        const popupContent = `
          <div style="min-width:300px;">
            <h4 style="margin:0 0 10px 0; text-align:center;">${regionName}</h4>
            <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;">
              <div style="width:32%; min-width:220px;">
                <strong>Schools:</strong>
                <ul style="padding-left:18px; margin-top:4px;">${schoolsHtml}</ul>
              </div>
              <div style="width:32%; min-width:220px;">
                <strong>Tournaments:</strong>
                <ul style="padding-left:18px; margin-top:4px;">${tournamentsHtml}</ul>
              </div>
              <div style="width:32%; min-width:220px;">
                <strong>Qualifiers:</strong>
                <ul style="padding-left:18px; margin-top:4px;">${qualifiersHtml}</ul>
              </div>
            </div>
          </div>
        `;

        L.geoJSON(regionFeature, {
          pane: 'regionPane',
          style: { opacity: 0, fillOpacity: 0, weight: 0 },
          onEachFeature: (_, layer) => {
            layer.on('click', e => {
              if (e.originalEvent && e.originalEvent._clickedSchool) return; // ignore school clicks
              map.fitBounds(layer.getBounds());
              const center = layer.getBounds().getCenter();
              layer.bindPopup(popupContent).openPopup(center);
            });
          }
        }).addTo(schoolRegionLayer);
      });

      try { map.fitBounds(regionsVisible.getBounds(), { padding: [20,20] }); } catch (e) {}
    })
    .catch(err => console.error(err));

    // Layer toggle
    L.control.layers(null, {
      "Regions & Schools": schoolRegionLayer,
      "Tournaments": tournamentLayer,
      "Qualifiers": qualifierLayer
    }, { collapsed: false }).addTo(map);
  </script>
</body>
</html>









