<!DOCTYPE html>
<html>
<head>
  <title>NCCGA Regional Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { margin:0; padding:0; }
    #map { height: 100vh; }

    /* Search UI */
   .search-wrap{
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);   /* center horizontally */
  z-index: 1000;
  width: min(280px, 92vw);        /* roomy on desktop, fits on mobile */
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

    .search-input{
      width:100%; box-sizing:border-box;
      padding:10px 12px; border:1px solid #bbb; border-radius:8px;
      box-shadow: 0 2px 6px rgba(0,0,0,.1); outline:none; background:#fff;
    }
    .search-input:focus{ border-color:#4e7cf1; box-shadow:0 0 0 3px rgba(78,124,241,.15); }
    .results{
      margin-top:6px; background:#fff; border:1px solid #ddd; border-radius:8px; overflow:hidden;
      box-shadow:0 8px 18px rgba(0,0,0,.12); max-height:320px; overflow-y:auto; display:none;
    }
    .result-item{
      padding:8px 10px; cursor:pointer; display:flex; align-items:center; justify-content:space-between;
    }
    .result-item:hover, .result-item.active{ background:#f2f6ff; }
    .result-left{ display:flex; gap:8px; align-items:center; }
    .result-type{
      font-size:11px; text-transform:uppercase; letter-spacing:.04em; color:#666; background:#f3f3f3; padding:2px 6px; border-radius:6px;
    }
    .result-title{ font-size:14px; color:#222; }
    .result-sub{ font-size:12px; color:#666; }

    .qualifier-icon {
      filter: drop-shadow(0 0 2px #fff) drop-shadow(0 0 1.5px #000);
    }
    .leaflet-div-icon.flag-div { background: transparent; border: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Search UI -->
  <div class="search-wrap">
    <input id="searchInput" class="search-input" type="text" placeholder="Search schools, tournaments, qualifiers, regionsâ€¦" autocomplete="off">
    <div id="results" class="results"></div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Turf for point-in-polygon + buffering line regions -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const map = L.map('map').setView([39.5, -98.35], 4);

    // ===== Panes & stacking order =====
    map.createPane('regionPane');     map.getPane('regionPane').style.zIndex = 450;
    map.createPane('schoolPane');     map.getPane('schoolPane').style.zIndex = 650;
    map.createPane('tournamentPane'); map.getPane('tournamentPane').style.zIndex = 660;
    map.createPane('qualifierPane');  map.getPane('qualifierPane').style.zIndex = 670;

    // ---------- Normalizer (used for grouping keys only) ----------
    const clean = str => String(str || '')
      .toLowerCase()
      .replace(/region/g, '')
      .replace(/capitol/g, 'capital')
      .replace(/[\s\-_().]/g, '')
      .trim();

    // ---------- Fixed palette (yours) ----------
    const REGION_COLORS = {
      "Atlantic Region":             "#1f78b4",
      "Northeast Region":            "#33a02c",
      "Capitol Region":              "#e31a1c",
      "Colonial Region":             "#ff7f00",
      "North Carolina Region":       "#FF69B4",
      "Desert Region":               "#b15928",
      "Mountain Region":             "#a6cee3",
      "Pacific Region":              "#b2df8a",
      "Northwest Region":            "#fb9a99",
      "Ohio Valley Region":          "#fdbf6f",
      "Midwest Region":              "#cab2d6",
      "Southern New England Region": "#80cdc1",
      "Texas Region":                "#5e3c99",
      "Northern California Region":  "#c51b7d",
      "Southern California Region":  "#35978f",
      "Indiana Region":              "#80b1d3",
      "Northern New England Region": "#8B4513",
      "Twin Cities Region":          "#33a02c",
      "Great Lakes Region":          "#800000",
      "Philadelphia Region":         "#4B0082",
      "Metro Region":                "#000080",
      "Florida Region":              "#FF69B4",
      "Gulf Region":                 "#A2AD00",
      "Central Region":              "#9C27B0",
      "North Region":                "#CC5500",
      "Southeast Region":            "#C7EA46",
      "Ozark Region":                "#808080"
      
    };

    const COLOR_BY_KEY = {};
    Object.entries(REGION_COLORS).forEach(([name, color]) => {
      COLOR_BY_KEY[clean(name)] = color;
    });

    // Optional short aliases you might see in data
    const REGION_ALIASES = {
      philadelphia: 'colonial', philly: 'colonial',
      tx: 'texas',
      norcal: 'northerncalifornia', nocal: 'northerncalifornia',
      socal: 'southerncalifornia',  scal: 'southerncalifornia'
    };

    // Prefer the tournament's label; fall back to polygon if unknown
    const PREFER_TOURNAMENT_LABEL = true;

    function hashColor(name = "default") {
  name = String(name ?? "default"); // âœ… force string so .length and .charCodeAt work
  let h = 0;
  for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) | 0;
  const hue = Math.abs(h) % 360;
  return `hsl(${hue},70%,45%)`;
}

    function getRegionColorByName(name) {
      const key = clean(name);
      return COLOR_BY_KEY[key] || hashColor(name || "");
    }
    function resolveRegionKey(name) {
      const k = clean(name);
      if (COLOR_BY_KEY[k]) return k;
      const alias = REGION_ALIASES[k];
      if (alias && COLOR_BY_KEY[alias]) return alias;
      return k;
    }

    // Layers
    const schoolRegionLayer = L.layerGroup().addTo(map);
    const tournamentLayer   = L.layerGroup().addTo(map);
    const qualifierLayer    = L.layerGroup().addTo(map);

    // Basemap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const bottomCenterAnchor = size => [Math.round(size[0] / 2), size[1]];
    const loadJSON = (url) => fetch(url).then(r => { if (!r.ok) throw new Error(url+': '+r.status); return r.json(); });

    // ===== Season State =====
    // Seasons are NCCGA "academic" seasons (e.g., 2025/2026)
    const ALL_SEASONS = ["2025/2026", "2026/2027"];
    let ACTIVE_SEASON = "2025/2026"; // single-select default

    function seasonToKey(season){
      // "2026/2027" -> "2026_2027"
      return String(season || "").replace("/", "_");
    }


    // === SVG tournament flag (cloth colorable) ===
    function makeSvgFlagIcon(color, size = [18, 24]) {
      const [w, h] = size;
      const html = `
        <svg width="${w}" height="${h}" viewBox="0 0 18 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <ellipse cx="9" cy="22" rx="6" ry="3" fill="#000"/>
          <rect x="8" y="3" width="2" height="18" fill="#000"/>
          <polygon points="10,6 10,12 18,9" fill="${color}"/>
        </svg>`;
      return L.divIcon({
        html,
        className: 'flag-div',
        iconSize: [w, h],
        iconAnchor: [Math.round(w/2), h],
        popupAnchor: [0, -Math.round(h*0.8)]
      });
    }

    // ===== Search Index =====
    const searchIndex = [];  // {type, title, sub, select(), terms}
    function addToIndex(entry){ searchIndex.push(entry); }

    // ===== Load data (regions first so we can color tournaments) =====
    Promise.all([
      loadJSON('regions.geojson'),
      loadJSON('schools.geojson').catch(() => null),
    ]).then(([regions, schools]) => {

      // --- Convert non-polygon region geometries into thin polygons for hit-testing ---
      function toPolygonFeature(feat) {
        const g = feat && feat.geometry ? feat.geometry : {};
        if (g.type === 'Polygon' || g.type === 'MultiPolygon') return feat;
        try {
          // buffer by ~5 km to create a polygon shell around lines
          return turf.buffer(feat, 5, { units: 'kilometers' });
        } catch {
          return feat; // fallback (won't match, but won't crash)
        }
      }

      // --- Build region polygon list for point-in-polygon coloring ---
      const regionPolys = (regions?.features || []).map(f => {
        const polyFeat = toPolygonFeature(f);
        return {
          feature: polyFeat,
          key: clean(f.properties?.region),
          name: f.properties?.region,
          color: getRegionColorByName(f.properties?.region)
        };
      });

      // Prefer label; fall back to polygon; final fallback = hashed color
      function colorAndKeyForPointOrLabel(lat, lng, labelName) {
        const labelKey = resolveRegionKey(labelName);
        const labelKnown = !!COLOR_BY_KEY[labelKey];

        if (PREFER_TOURNAMENT_LABEL && labelKnown) {
          return { color: COLOR_BY_KEY[labelKey], key: labelKey, name: labelName || '', source: 'label' };
        }

        const pt = turf.point([lng, lat]);
        for (const r of regionPolys) {
          if (turf.booleanPointInPolygon(pt, r.feature)) {
            return { color: r.color, key: r.key, name: r.name, source: 'polygon' };
          }
        }

        return { color: hashColor(labelName || ''), key: labelKey, name: labelName || '', source: 'fallback' };
      }

      // --- Visible region outlines (non-interactive) ---
      const regionsVisible = L.geoJSON(regions, {
        pane: 'regionPane',
        style: f => ({
          color: getRegionColorByName(f.properties?.region),
          weight: 2,
          fillOpacity: 0.2,
          interactive: false
        })
      }).addTo(schoolRegionLayer);

      // --- Schools (bottom layer; clicks must win) ---
      if (schools) {
        L.geoJSON(schools, {
          pane: 'schoolPane',
          pointToLayer: (feature, latlng) => {
            const p = feature.properties || {};
            const color = getRegionColorByName(p.region);
            const url = `https://nccga.org/app/teams/${p.slug}`;

            const m = L.circleMarker(latlng, {
              pane: 'schoolPane',
              radius: 6,
              fillColor: color,
              color: "#333",
              weight: 1,
              opacity: 1,
              fillOpacity: 0.9,
              bubblingMouseEvents: false,
              interactive: true
            });

            m.on('click', e => {
              if (e.originalEvent) {
                L.DomEvent.stop(e.originalEvent);
                e.originalEvent._clickedSchool = true;
              }
              m.bindPopup(
                `<strong><a href="${url}" target="_blank">${p.school}</a></strong><br>${p.region}`
              ).openPopup();
              if (m.bringToFront) m.bringToFront();
            });

            // Add to search
            addToIndex({
              type: 'School',
              title: p.school,
              sub: p.region,
              terms: `${p.school} ${p.region}`.toLowerCase(),
              select: () => {
                map.setView(m.getLatLng(), Math.max(map.getZoom(), 9), { animate: true });
                m.fire('click');
              }
            });

            return m;
          }
        }).addTo(schoolRegionLayer);
      }

      // --- Storage for popup lists (rebuilt when seasons change) ---
      let tournamentsByRegionKey = {};
      let qualifiersByRegionKey  = {};

      // --- Qualifiers (top layer; PNG icon) ---
      const QUAL_SIZE = [26, 26];
      const qualifierIcon = L.icon({
        iconUrl: 'img/Qualifier_flag_icon.png',
        iconSize: QUAL_SIZE,
        iconAnchor: bottomCenterAnchor(QUAL_SIZE),
        popupAnchor: [0, -Math.round(QUAL_SIZE[1] * 0.9)],
        className: 'qualifier-icon'
      });

      // --- Season-aware loader for Tournaments + Qualifiers (schools & regions stay static) ---
      async function loadSeasonalCompetitions(){
        // Clear layers
        tournamentLayer.clearLayers();
        qualifierLayer.clearLayers();

        // Reset popup lists for regions
        tournamentsByRegionKey = {};
        qualifiersByRegionKey  = {};
        // If no season selected, leave comps blank
        if (!ACTIVE_SEASON) return;

        const season = ACTIVE_SEASON;
        const key = seasonToKey(season);
        const TOURN_SIZE = [18, 24];

        const [tournaments, qualifiers] = await Promise.all([
          loadJSON(`tournaments_${key}.geojson`).catch(() => null),
          loadJSON(`qualifiers_${key}.geojson`).catch(() => null),
        ]);

          // --- Tournaments ---
          if (tournaments) {
            L.geoJSON(tournaments, {
              pane: 'tournamentPane',
              pointToLayer: (feature, latlng) => {
                const p = feature.properties || {};
                const { color, name: polyName, key: regionKey } =
  colorAndKeyForPointOrLabel(latlng.lat, latlng.lng, p.region);

// Use the SAME key the popup uses: clean(region polygon name)
const popupKey = clean(polyName || p.region || regionKey);
(tournamentsByRegionKey[popupKey] ||= []).push({ ...p, season });

                const marker = L.marker(latlng, {
                  icon: makeSvgFlagIcon(color, TOURN_SIZE),
                  pane: 'tournamentPane',
                  zIndexOffset: 0
                });

                // bind popup
                const html = (() => {
  let s = `<strong>${p.course_name || 'Tournament'}</strong>`;
  if (p.region) s += `<br>${p.region}`;
  if (p.date)   s += `<br><em>${p.date}</em>`;
  s += `<br><span style="font-size:12px;color:#666;">Season: ${season}</span>`;

  // âœ… Tournament leaderboard link
  if (p.id) {
    const leaderboardUrl = getTournamentLeaderboardUrl(p.id);
    if (leaderboardUrl) {
      s += `<br><a href="${leaderboardUrl}" target="_blank" rel="noopener noreferrer">Tournament Page</a>`;
    }
  }

  if (p.website) s += `<br><a href="${p.website}" target="_blank">Course Website</a>`;
  return s;
})();

marker.bindPopup(html);

                return marker;
              }
            }).addTo(tournamentLayer);
          }

          // --- Qualifiers ---
          if (qualifiers) {
            L.geoJSON(qualifiers, {
              pane: 'qualifierPane',
              pointToLayer: (feature, latlng) => {
                const p = feature.properties || {};

                const marker = L.marker(latlng, {
                  icon: qualifierIcon,
                  pane: 'qualifierPane',
                  zIndexOffset: 100
                });

const regionArr =
  (Array.isArray(p.regions) && p.regions.length) ? p.regions :
  (Array.isArray(p.region)  && p.region.length)  ? p.region  :
  null;

const label = regionArr ? regionArr.join(', ') : (p.region || 'Qualifier');
let html = `<strong>${p.course_name || 'Qualifier'}</strong><br>${label}`;
if (p.date) html += `<br><em>${p.date}</em>`;
if (p.registration || p.registration_url) {
  const regLink = p.registration || p.registration_url;

  html += `<br><a href="${regLink}" target="_blank" rel="noopener noreferrer"
            style="color:#2e7d32; font-weight:600;">
            Register Now
           </a>`;

  // âœ… Add closing date text if provided
  if (p.registration_closes) {
    html += ` <span style="font-weight:600; color:#1b365d;">
                (Closes ${p.registration_closes})
              </span>`;
  }
}
else if (p.tournament_page || p.leaderboard_url) {
  const lbLink = p.tournament_page || p.leaderboard_url;
  html += `<br><a href="${lbLink}" target="_blank" rel="noopener noreferrer">
            Leaderboard
           </a>`;
}
if (p.website) {
  html += `<br><a href="${p.website}" target="_blank">Course Website</a>`;
}

marker.bindPopup(html);

                // Index by given region labels (if any)
                // Bucket for region popups using the SAME key the region polygon popup uses
// ---- Bucket qualifiers for ALL regions they belong to ----
let regionLabels = [];

// Prefer explicit regions array
if (Array.isArray(p.regions) && p.regions.length) {
  regionLabels = p.regions;
} 
// Fall back to comma-separated string
else if (typeof p.region === "string" && p.region.trim()) {
  regionLabels = p.region.split(",").map(s => s.trim()).filter(Boolean);
}

// Final fallback: infer by location
if (!regionLabels.length) {
  const match = colorAndKeyForPointOrLabel(
    latlng.lat,
    latlng.lng,
    p.region || ''
  );
  const fallbackKey = clean(match.key || match.name || p.region || '');
  if (fallbackKey) regionLabels = [fallbackKey];
}

// Add qualifier to EVERY region bucket
regionLabels
  .map(lbl => clean(lbl))
  .filter(Boolean)
  .forEach(rk => {
    (qualifiersByRegionKey[rk] ||= []).push({ ...p, season });
  });

return marker;


              }
            }).addTo(qualifierLayer);
          }
      }
      window.loadSeasonalCompetitions = loadSeasonalCompetitions;


      /***********************
       * GLOBAL SEARCH INDEX (ALL SEASONS)
       * - Search always includes tournaments + qualifiers from every season
       * - Clicking a result auto-switches the season + reloads map + opens popup
       ************************/

      // Dedup so we don't re-add the same search items
      const compIndexKeys = new Set();

      function compKey(type, season, p, latlng){
        const name = String((p && (p.course_name || p.course)) || "").toLowerCase().trim();
        const reg  = String((p && (p.region || (Array.isArray(p.regions) ? p.regions.join(",") : ""))) || "").toLowerCase().trim();
        return `${type}|${season}|${name}|${reg}|${latlng.lat.toFixed(6)}|${latlng.lng.toFixed(6)}`;
      }

      // Find a marker in a layer group by exact lat/lng match
      function findMarkerByLatLng(layerGroup, latlng){
        let found = null;
        layerGroup.eachLayer(layer => {
          if (!layer || !layer.getLatLng) return;
          const ll = layer.getLatLng();
          if (Math.abs(ll.lat - latlng.lat) < 1e-9 && Math.abs(ll.lng - latlng.lng) < 1e-9) {
            found = layer;
          }
        });
        return found;
      }

      async function buildAllSeasonCompetitionIndex(){
        for (const season of ALL_SEASONS){
          const key = seasonToKey(season);

          const [tournaments, qualifiers] = await Promise.all([
            loadJSON(`tournaments_${key}.geojson`).catch(() => null),
            loadJSON(`qualifiers_${key}.geojson`).catch(() => null),
          ]);

          // ---- TOURNAMENTS (all seasons) ----
          if (tournaments && tournaments.features && tournaments.features.length){
            for (const f of tournaments.features){
              if (!f || !f.geometry || f.geometry.type !== "Point") continue;
              const coords = f.geometry.coordinates || [];
              const lng = coords[0], lat = coords[1];
              if (typeof lat !== "number" || typeof lng !== "number") continue;

              const latlng = L.latLng(lat, lng);
              const p = f.properties || {};

              const u = compKey("Tournament", season, p, latlng);
              if (compIndexKeys.has(u)) continue;
              compIndexKeys.add(u);

              addToIndex({
                type: "Tournament",
                title: p.course_name || "Tournament",
                sub: `${p.region || ""}${p.region ? " â€¢ " : ""}${season}`,
                terms: `${p.course_name || ""} ${p.region || ""}`.toLowerCase(),
                select: async () => {
                  if (ACTIVE_SEASON !== season) {
                    setActiveSeason(season);
                    if (typeof window.loadSeasonalCompetitions === "function") {
                      await window.loadSeasonalCompetitions();
                    }
                  }
                  map.setView(latlng, Math.max(map.getZoom(), 9), { animate: true });
                  const m = findMarkerByLatLng(tournamentLayer, latlng);
                  if (m && m.openPopup) m.openPopup();
                }
              });
            }
          }

          // ---- QUALIFIERS (all seasons) ----
          if (qualifiers && qualifiers.features && qualifiers.features.length){
            for (const f of qualifiers.features){
              if (!f || !f.geometry || f.geometry.type !== "Point") continue;
              const coords = f.geometry.coordinates || [];
              const lng = coords[0], lat = coords[1];
              if (typeof lat !== "number" || typeof lng !== "number") continue;

              const latlng = L.latLng(lat, lng);
              const p = f.properties || {};
              const label = Array.isArray(p.regions) ? p.regions.join(", ") : (p.region || "");

              const u = compKey("Qualifier", season, p, latlng);
              if (compIndexKeys.has(u)) continue;
              compIndexKeys.add(u);

              addToIndex({
                type: "Qualifier",
                title: p.course_name || "Qualifier",
                sub: `${label || ""}${label ? " â€¢ " : ""}${season}`,
                terms: `${p.course_name || ""} ${label}`.toLowerCase(),
                select: async () => {
                  if (ACTIVE_SEASON !== season) {
                    setActiveSeason(season);
                    if (typeof window.loadSeasonalCompetitions === "function") {
                      await window.loadSeasonalCompetitions();
                    }
                  }
                  map.setView(latlng, Math.max(map.getZoom(), 9), { animate: true });
                  const m = findMarkerByLatLng(qualifierLayer, latlng);
                  if (m && m.openPopup) m.openPopup();
                }
              });
            }
          }
        }
      }

      // Build global competition search once
      buildAllSeasonCompetitionIndex();

    function getTournamentLeaderboardUrl(id){
  if (!id) return null;
  return `https://nccga.org/app/golf-tournaments/${id}/team-player-leaderboard`;
}
  

      // Build region popup content dynamically so it always reflects the ACTIVE_SEASON
      function buildRegionPopupContent(regionKey, regionName, schoolsList){
  const key = regionKey; // already cleaned
  const schools = Array.isArray(schoolsList) ? schoolsList : [];

  const tList = (tournamentsByRegionKey[key] || []).slice();
  const qList = (qualifiersByRegionKey[key] || []).slice();

  // Sort tournaments by date (earliest first)
  function parseDateRangeStart(s){
    if (!s) return Infinity;

    // Get the first "Month Day" and the 4-digit year from strings like:
    // "October 11-12, 2025" or "March 28-29, 2026"
    const m = String(s).match(/[A-Za-z]+\s+\d{1,2}/);
    const y = String(s).match(/\b(20\d{2})\b/);
    if (!m || !y) return Infinity;

    const base = `${m[0]}, ${y[1]}`;
    const d = new Date(base);
    return isNaN(d.getTime()) ? Infinity : d.getTime();
  }

  tList.sort((a,b) => parseDateRangeStart(a.date) - parseDateRangeStart(b.date));

  const schoolsHtml = (schools.length
    ? schools.map(s => `<li>${s}</li>`).join('')
    : '<li>No schools listed.</li>');

  const tournamentsHtml = (tList.length
  ? tList.map(t => {
      let html = `<li><strong>${t.course_name || 'Tournament'}</strong>`;

      if (t.date) {
        html += `<br><em>${t.date}</em>`;
      }

      // ðŸ”— Tournament leaderboard link
      const leaderboardUrl = getTournamentLeaderboardUrl(t.id);
      if (leaderboardUrl) {
        html += `<br><a href="${leaderboardUrl}" target="_blank" rel="noopener noreferrer">
          Tournament Page
        </a>`;
      }

      if (t.website) {
        html += `<br><a href="${t.website}" target="_blank">Course Website</a>`;
      }

      html += `</li>`;
      return html;
    }).join('')
  : '<li>No tournaments scheduled.</li>');


  // No need to show "Season:" per item (header already shows active season)
  const qualifiersHtml = (qList.length
    ? qList.map(q => {
        let html = `<li><strong>${q.course_name || q.course || 'Qualifier'}</strong>`;
        if (q.date) html += `<br><em>${q.date}</em>`;
        if (q.website) html += `<br><a href="${q.website}" target="_blank">Course Website</a>`;
        html += `</li>`;
        return html;
      }).join('')
    : '<li>No qualifiers scheduled.</li>');

  const seasonsLine = ACTIVE_SEASON ? ACTIVE_SEASON : 'None';

  return `
    <div style="
      width: 260px;
      max-height: 45vh;
      overflow-y: auto;
      font-size: 12px;
      line-height: 1.25;
    ">
      <h4 style="margin:0 0 6px 0; text-align:center; font-size:14px;">
        ${regionName}
      </h4>

      <div style="text-align:center; font-size:11px; color:#666; margin-bottom:6px;">
        Showing season: ${seasonsLine}
      </div>

      <strong>Schools:</strong>
      <ul style="padding-left:14px; margin:3px 0 6px 0;">
        ${schoolsHtml}
      </ul>

      <strong>Tournaments:</strong>
      <ul style="padding-left:14px; margin:3px 0 6px 0;">
        ${tournamentsHtml}
      </ul>

      <strong>Qualifiers:</strong>
      <ul style="padding-left:14px; margin:3px 0;">
        ${qualifiersHtml}
      </ul>
    </div>
  `;
}



      
      // --- Invisible interactive region layer for popups/zoom + add regions to search ---
      regions.features.forEach(regionFeature => {
        const regionName = regionFeature.properties?.region || 'Region';
        const regionKey  = clean(regionName);
        const schoolsList = regionFeature.properties?.schools || [];

        let interactiveLayerRef = null;

        L.geoJSON(regionFeature, {
          pane: 'regionPane',
          style: { opacity: 0, fillOpacity: 0, weight: 0 },
          onEachFeature: (_, layer) => {
            interactiveLayerRef = layer;

            layer.on('click', e => {
              if (e.originalEvent && e.originalEvent._clickedSchool) return; // ignore school clicks
              map.fitBounds(layer.getBounds());
              const center = layer.getBounds().getCenter();

              // IMPORTANT: popup content generated at open-time (reflects ACTIVE_SEASON + current lists)
              layer.bindPopup(() => buildRegionPopupContent(regionKey, regionName, schoolsList)).openPopup(center);
            });
          }
        }).addTo(schoolRegionLayer);

        // Add region to search (zoom and open its popup)
        addToIndex({
          type: 'Region',
          title: regionName,
          sub: 'Region',
          terms: regionName.toLowerCase(),
          select: () => {
            if (!interactiveLayerRef) return;
            const b = interactiveLayerRef.getBounds();
            map.fitBounds(b, { padding: [20, 20] });
            const center = b.getCenter();
            interactiveLayerRef.bindPopup(() => buildRegionPopupContent(regionKey, regionName, schoolsList)).openPopup(center);
          }
        });
      });


      // Load default season tournaments/qualifiers
      loadSeasonalCompetitions();

      try { map.fitBounds(regionsVisible.getBounds(), { padding: [20,20] }); } catch (e) {}

      // ===== Wire up Search =====
      const input = document.getElementById('searchInput');
      const resultsEl = document.getElementById('results');
      let activeIndex = -1;

      function doSearch(q){
        const query = q.trim().toLowerCase();
        resultsEl.innerHTML = '';
        resultsEl.style.display = 'none';
        activeIndex = -1;
        if (!query) return;

        // simple scoring: startsWith > includes
        const matches = [];
        for (const item of searchIndex) {
          const t = item.terms || '';
          if (!t) continue;
          if (t.startsWith(query)) matches.push({score: 2, item});
          else if (t.includes(query)) matches.push({score: 1, item});
        }
        matches.sort((a,b)=> b.score - a.score || a.item.title.localeCompare(b.item.title));
        const top = matches.slice(0, 12);

        if (!top.length) return;

        for (let i=0; i<top.length; i++){
          const { item } = top[i];
          const div = document.createElement('div');
          div.className = 'result-item';
          div.dataset.idx = String(i);

          div.innerHTML = `
            <div class="result-left">
              <span class="result-type">${item.type}</span>
              <div>
                <div class="result-title">${item.title}</div>
                <div class="result-sub">${item.sub || ''}</div>
              </div>
            </div>
          `;
          div.addEventListener('click', () => {
            resultsEl.style.display = 'none';
            input.blur();
            item.select && item.select();
          });
          resultsEl.appendChild(div);
        }
        resultsEl.style.display = 'block';
      }

      input.addEventListener('input', (e)=> doSearch(e.target.value));

      input.addEventListener('keydown', (e)=>{
        const items = Array.from(resultsEl.querySelectorAll('.result-item'));
        if (!items.length) return;

        if (e.key === 'ArrowDown'){
          e.preventDefault();
          activeIndex = (activeIndex + 1) % items.length;
        } else if (e.key === 'ArrowUp'){
          e.preventDefault();
          activeIndex = (activeIndex - 1 + items.length) % items.length;
        } else if (e.key === 'Enter'){
          e.preventDefault();
          if (activeIndex >=0) items[activeIndex].click();
          return;
        } else if (e.key === 'Escape'){
          resultsEl.style.display = 'none';
          input.blur();
          return;
        } else {
          return; // let input handler run
        }

        items.forEach((el, i)=> el.classList.toggle('active', i===activeIndex));
        const activeEl = items[activeIndex];
        if (activeEl){
          const r = activeEl.getBoundingClientRect();
          const c = resultsEl.getBoundingClientRect();
          if (r.bottom > c.bottom) activeEl.scrollIntoView(false);
          if (r.top < c.top) activeEl.scrollIntoView();
        }
      });

      // Hide results when clicking map or elsewhere
      map.on('click', ()=> { resultsEl.style.display = 'none'; });
      document.addEventListener('click', (e)=>{
        if (!document.querySelector('.search-wrap').contains(e.target)) {
          resultsEl.style.display = 'none';
        }
      });
    })
    .catch(err => console.error(err));

    // Layer toggle
    const layerControl = L.control.layers(null, {
  "Regions & Schools": schoolRegionLayer,
  "Tournaments": tournamentLayer,
  "Qualifiers": qualifierLayer
}, { collapsed: false }).addTo(map);
// ===== Season Filter UI (injected under layer control) =====
function addSeasonUI({ years, defaultYear }) {
  const layerEl = document.querySelector(".leaflet-control-layers");
  if (!layerEl) return null;

  const box = document.createElement("div");
  box.className = "season-control";
  box.style.marginTop = "8px";
  box.style.paddingTop = "8px";
  box.style.borderTop = "1px solid rgba(0,0,0,0.2)";

  box.innerHTML = `
    <div style="font-weight:600; margin-bottom:6px;">Season</div>
    ${years.map(y => `
      <label style="display:flex; gap:6px; font-size:13px; cursor:pointer;">
        <input type="radio" name="seasonChoice" value="${y}" class="season-year">
        ${y}
      </label>
    `).join("")}
  `;

  layerEl.appendChild(box);

  const radios = [...box.querySelectorAll(".season-year")];
  radios.forEach(r => r.checked = (r.value === defaultYear));

  return { box, radios };
}

// --- helper used by search results ---
function setActiveSeason(season){
  ACTIVE_SEASON = season;

  const radio = document.querySelector(
    `input[name="seasonChoice"][value="${season}"]`
  );
  if (radio) radio.checked = true;
}

function hookSeasonUI(ui){
  if (!ui) return;
  const { radios } = ui;

  function syncFromUI(){
    const selected = radios.find(r => r.checked);
    ACTIVE_SEASON = selected ? selected.value : null;

    if (typeof window.loadSeasonalCompetitions === "function") {
      window.loadSeasonalCompetitions();
    }
  }

  radios.forEach(r => r.addEventListener("change", syncFromUI));
  syncFromUI(); // initial load
}

// Initialize Season UI
const seasonUI = addSeasonUI({
  years: ALL_SEASONS,
  defaultYear: ACTIVE_SEASON
});
hookSeasonUI(seasonUI);




  </script>
</body>
</html>










